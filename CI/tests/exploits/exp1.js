let fs = require('fs');
let path = require('path');
let solc = require('solc');
let assert = require('assert');
let chalk = require('chalk');
let axios = require('axios');


// Load the ProductOrder.sol source code
let productOrderSource = fs.readFileSync(path.join(__dirname, '..', '..', '..', 'contracts', 'source', 'ProductOrder.sol'), 'utf8');

// Extract solc version from the source
function extractSolcVersion(source) {
    let match = source.match(/^pragma solidity (\^?\d+\.\d+\.\d+);/m);
    if (match) {
        return match[1].slice(1);  // remove the '^' character
    }
    throw new Error('No valid pragma directive found in the Solidity source.');
}



async function getSolcVersions() {
    try {
        let response = await axios.get('https://binaries.soliditylang.org/bin/list.json');
        return response.data;
    } catch (error) {
        console.error("Error fetching versions:", error);
        throw error;
    }
}

async function compileWithVersion(source, version) {
    let solcVersions = await getSolcVersions();
    let exactVersion = solcVersions.releases[version];

    if (!exactVersion) {
        throw new Error(`Exact version for ${version} not found in solc releases.`);
    }

    // Fetch the specific compiler version using axios
    let solcUrl = `https://binaries.soliditylang.org/bin/${exactVersion}`;
    let response = await axios.get(solcUrl);
    let solcSource = response.data;

    // Load the fetched compiler version using solc
    let solcInstance = solc.setupMethods(requireFromString(solcSource));

    let input = {
        language: 'Solidity',
        sources: {
            'ProductOrder.sol': {
                content: source
            }
        },
        settings: {
            outputSelection: {
                '*': {
                    '*': ['*']
                }
            }
        }
    };

    let output = JSON.parse(solcInstance.compile(JSON.stringify(input)));
    let contract = output.contracts['ProductOrder.sol']['ProductOrder'];
    return {
        abi: contract.abi,
        bytecode: contract.evm.bytecode.object
    };
}

// Helper function to require from a string
function requireFromString(src, filename) {
    let m = new module.constructor();
    m.paths = module.paths;
    m._compile(src, filename || 'unknown');
    return m.exports;
}

async function deployContract(web3, abi, bytecode, envInfo, constructorParameters) {
    let contract = new web3.eth.Contract(abi);

    // Assuming the constructor expects a single parameter, for example:
    let constructorParams = [1]; // replace 'paramValue' with the actual value or values

    // Estimate gas
    let gasEstimate = await contract.deploy({ data: bytecode, arguments: constructorParams }).estimateGas({
        from: envInfo.accounts[0]
    });


    let deployedContract;
    try {
        deployedContract = await contract.deploy({ data: bytecode, arguments: constructorParams }).send({
            from: envInfo.accounts[0],
            gas: gasEstimate,
            gasPrice: '30000000000000'
        });
    } catch (error) {
        console.error("Error deploying the contract:", error);
        throw error;
    }
    return deployedContract;
}


async function exploit(web3, envInfo) {
    let solcVersion = extractSolcVersion(productOrderSource);
    let { abi, bytecode } = await compileWithVersion(productOrderSource, solcVersion);
    let contractInstance = await deployContract(web3, abi, bytecode, envInfo);

    // Our exploit logic here using contractInstance
    // For example:
    // await contractInstance.methods.someMethod().send({ from: web3.eth.accounts.wallet[0].address });
}

module.exports = async function runTests(web3, envInfo) {
    // envInfo.accounts, envInfo.privateKeys, and envInfo.rpcAddress should be available from Anvil 
    // Execute the exploit
    await exploit(web3, envInfo);

    // See if exploit has yielded the predicted result (a very manual oracle!)
    // For example:
    // let result = await someContractMethod.call();
    // assert.strictEqual(result, expectedValue, "Exploit did not yield the expected result");
}
