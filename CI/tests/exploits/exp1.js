let fs = require('fs');
let path = require('path');
let assert = require('assert');
let chalk = require('chalk');
let { 
    extractSolcVersion, 
    getSolcVersions, 
    compileWithVersion, 
    requireFromString,
    deployContract 
} = require('./../../../lib/web3/utils');


// Load the ProductOrder.sol source code
let productOrderSource = fs.readFileSync(path.join(__dirname, '..', '..', '..', 'contracts', 'source', 'ProductOrder.sol'), 'utf8');


async function exploit(web3, envInfo) {
    let solcVersion = extractSolcVersion(productOrderSource);
    let { abi, bytecode } = await compileWithVersion(productOrderSource, solcVersion);
    let parameters = [1];
    let contractInstance = await deployContract(web3, abi, bytecode, envInfo, parameters);

    // Our exploit logic here using contractInstance
    // For example:
    // await contractInstance.methods.someMethod().send({ from: web3.eth.accounts.wallet[0].address });
}

module.exports = async function runTests(web3, envInfo) {
    // envInfo.accounts, envInfo.privateKeys, and envInfo.rpcAddress should be available from Anvil 
    // Execute the exploit
    await exploit(web3, envInfo);

    // See if exploit has yielded the predicted result (a very manual oracle!)
    // For example:
    // let result = await someContractMethod.call();
    // assert.strictEqual(result, expectedValue, "Exploit did not yield the expected result");
}
